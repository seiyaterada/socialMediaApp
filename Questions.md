### Questions
1. <p>Normalized schemas breaks down complex data models into smaller, simpler tables. This makes storing data more efficient and organized over time. The trade off is that normalized scheams can require more complex quereis and joins which can slow down performance. <br><br> On the other hand denormalized schemas combine data from multiple tables into a single table. This can improve query performance by reducing the number of joins required. The trade off is that it can lead to data redundancy. For a social media platform denormalized schemas may be better since it will be designed for flexibility and scalability. But it will also depend on how many users you have and how much data is being stored since if you have lots of data it can lead to lots of data redundancy.</p>
2. <p>To support a query that searches for all posts with a particular tag in MongoDB, we would create an index on the tag field. Specifically, we would create a single-field index on the tag field using the following command:<br> `db.posts.createIndex({tag:1})`. <br> As the number of posts grows in the database, the performance of the index could be impacted. The size of the index will increase as the number of unique tags grow, which could lead to slower index build times and longer query times.</p>
3. <p>To add a location field in the existing collection you would add it with an update command like this:<br> `db.posts.updateMany({}, {$set: {location: ""}})`<br> Some potential issues with adding another field it could lead to slower updates, inconsistent data, and impact on indexes.</p>
4. <p>I would use a redis cache in a social media application to cache the posts data, as that will probably be accessed the most. I would probably store the post ID in the cache as the key instead of the entire post data as to not bloat the already small cache and make sure proper cache invalidation measures are enforced. I would handle cache invalidation by setting expiration times for the cached data or setting up a cache policy to define when data should be cached for how long. Some benefits of redis are that it offers faster access times to data, reduces database load, and increases scalability. Some drawbacks are that it can increase complexity and add additional storage requirements and costs.</p>
5. <p>RabbitMQ could be used as a message broker to handle real-time notification and messaging between users. When a user initiates an action that requries a notification, it can send a message to RabbitMQ exchange that corresponds to the type of notification. To ensure message persistence, we can store messages on disk to ensure that messages are not lost if a node fails. Replication can be ensured by storing messages on multiple nodes and keeping data backups can help with both.</p>
6. <p>One way is to use redis as a cache and set it up as a write-through cache. This way any updates made to redis are also immediately propagated to MongoDB. Another possible solution is to use transactions. By using transactions we can ensure that updates to the MongoDB and redis are performed atomically. Benefits would be that it will improve performance because of the redis cache and also increase data consistency through using transactions. Some drawbacks would be that it can add increased complexity since we would need to maintain cosistency and that there may be some latency between the updates.</p>